<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Genetic framework: gen::NSGAPopulation&lt; CBase, is_ref &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Genetic framework
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegen.html">gen</a></li><li class="navelem"><a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgen_1_1NSGAPopulation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gen::NSGAPopulation&lt; CBase, is_ref &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A variant of <a class="el" href="classgen_1_1Population.html" title="The main Population template, representing a collection of Candidates. This is the entry point of mos...">Population</a> enabling nondominance sorting and related selection methods.  
 <a href="classgen_1_1NSGAPopulation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="NSGAPopulation_8hpp_source.html">NSGAPopulation.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for gen::NSGAPopulation&lt; CBase, is_ref &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgen_1_1NSGAPopulation.png" usemap="#gen::NSGAPopulation_3C_20CBase_2C_20is_5Fref_20_3E_map" alt=""/>
  <map id="gen::NSGAPopulation_3C_20CBase_2C_20is_5Fref_20_3E_map" name="gen::NSGAPopulation&lt; CBase, is_ref &gt;_map">
<area href="classgen_1_1DomPopulation.html" alt="gen::DomPopulation&lt; CBase, is_ref, size_t, NSGAPopulation &gt;" shape="rect" coords="0,112,372,136"/>
<area href="classgen_1_1BasePopulation.html" alt="gen::BasePopulation&lt; CBase, is_ref, size_t, NSGAPopulation &gt;" shape="rect" coords="0,56,372,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa296f081375ad8b83ec5531ab33a2e1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a> = <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>&lt; CBase, true &gt;</td></tr>
<tr class="memdesc:aa296f081375ad8b83ec5531ab33a2e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A corresponding "reference population", a helper type for functions returning a selection from an existing population.  <a href="#aa296f081375ad8b83ec5531ab33a2e1a">More...</a><br /></td></tr>
<tr class="separator:aa296f081375ad8b83ec5531ab33a2e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73564a15c292253babac84911c0a1b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#af73564a15c292253babac84911c0a1b9">Val</a> = <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>&lt; CBase, false &gt;</td></tr>
<tr class="memdesc:af73564a15c292253babac84911c0a1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A corresponding "value population", a helper type for functions returning a selection from an existing population by value.  <a href="#af73564a15c292253babac84911c0a1b9">More...</a><br /></td></tr>
<tr class="separator:af73564a15c292253babac84911c0a1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a963cadb2360fd86ec92491c68242a7aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a963cadb2360fd86ec92491c68242a7aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1NSGAPopulation.html#a963cadb2360fd86ec92491c68242a7aa">NSGAPopulation</a> ()=default</td></tr>
<tr class="memdesc:a963cadb2360fd86ec92491c68242a7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty population. <br /></td></tr>
<tr class="separator:a963cadb2360fd86ec92491c68242a7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4b90d27c1ca5032cc0d3440ecfeac3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf4b90d27c1ca5032cc0d3440ecfeac3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#abf4b90d27c1ca5032cc0d3440ecfeac3">add</a> (const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;c)</td></tr>
<tr class="memdesc:abf4b90d27c1ca5032cc0d3440ecfeac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new candidate. <br /></td></tr>
<tr class="separator:abf4b90d27c1ca5032cc0d3440ecfeac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce2ec723e9809796baf35a3a581594b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ce2ec723e9809796baf35a3a581594b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a0ce2ec723e9809796baf35a3a581594b">add</a> (<a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;&amp;c)</td></tr>
<tr class="memdesc:a0ce2ec723e9809796baf35a3a581594b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes back a new candidate using the move semantics. <br /></td></tr>
<tr class="separator:a0ce2ec723e9809796baf35a3a581594b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174f881464476a392b8c21b9c0160da9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a174f881464476a392b8c21b9c0160da9">add</a> (size_t count, Source src, bool parallel=true)</td></tr>
<tr class="memdesc:a174f881464476a392b8c21b9c0160da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws <b>count</b> candidates from a source function <b>src</b>.  <a href="#a174f881464476a392b8c21b9c0160da9">More...</a><br /></td></tr>
<tr class="separator:a174f881464476a392b8c21b9c0160da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d91a055117d8ba2b82e4ff3884e8945"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d91a055117d8ba2b82e4ff3884e8945"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a4d91a055117d8ba2b82e4ff3884e8945">add</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a4d91a055117d8ba2b82e4ff3884e8945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies an iterator range from a container of <b>Candidate</b>s. <br /></td></tr>
<tr class="separator:a4d91a055117d8ba2b82e4ff3884e8945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6472f9b40dd1c1e6da79e76c9c22dc77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a6472f9b40dd1c1e6da79e76c9c22dc77">add</a> (const Container &amp;vec)</td></tr>
<tr class="memdesc:a6472f9b40dd1c1e6da79e76c9c22dc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all candidates from a container of <b>Candidate</b>s.  <a href="#a6472f9b40dd1c1e6da79e76c9c22dc77">More...</a><br /></td></tr>
<tr class="separator:a6472f9b40dd1c1e6da79e76c9c22dc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4513a92632c32a8e85509e6b9f38b3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#ad4513a92632c32a8e85509e6b9f38b3b">add</a> (Container &amp;&amp;vec)</td></tr>
<tr class="memdesc:ad4513a92632c32a8e85509e6b9f38b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all candidates from a container of <b>Candidate</b>s.  <a href="#ad4513a92632c32a8e85509e6b9f38b3b">More...</a><br /></td></tr>
<tr class="separator:ad4513a92632c32a8e85509e6b9f38b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5483ae56718c2675b7028b90a156da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa5483ae56718c2675b7028b90a156da"></a>
const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#aaa5483ae56718c2675b7028b90a156da">at</a> (size_t pos) const</td></tr>
<tr class="memdesc:aaa5483ae56718c2675b7028b90a156da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to a specified element by reference (with bounds checking). <br /></td></tr>
<tr class="separator:aaa5483ae56718c2675b7028b90a156da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ece2b4e2b9294d8cb91de2986dd58b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25ece2b4e2b9294d8cb91de2986dd58b"></a>
<a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a25ece2b4e2b9294d8cb91de2986dd58b">at_v</a> (size_t pos) const</td></tr>
<tr class="memdesc:a25ece2b4e2b9294d8cb91de2986dd58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a specified element by value (with bounds checking) <br /></td></tr>
<tr class="separator:a25ece2b4e2b9294d8cb91de2986dd58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66c9833836830880d55f803a21f19d0"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#ab66c9833836830880d55f803a21f19d0">begin</a> ()</td></tr>
<tr class="memdesc:ab66c9833836830880d55f803a21f19d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="#ab66c9833836830880d55f803a21f19d0">More...</a><br /></td></tr>
<tr class="separator:ab66c9833836830880d55f803a21f19d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9617849f9f39f1058ae5fdbc0a31fb3f"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a9617849f9f39f1058ae5fdbc0a31fb3f">begin</a> () const</td></tr>
<tr class="memdesc:a9617849f9f39f1058ae5fdbc0a31fb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the beginning.  <a href="#a9617849f9f39f1058ae5fdbc0a31fb3f">More...</a><br /></td></tr>
<tr class="separator:a9617849f9f39f1058ae5fdbc0a31fb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c77a3cf125a815c7c06dead2a08e75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31c77a3cf125a815c7c06dead2a08e75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a31c77a3cf125a815c7c06dead2a08e75">clear</a> ()</td></tr>
<tr class="memdesc:a31c77a3cf125a815c7c06dead2a08e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the population. <br /></td></tr>
<tr class="separator:a31c77a3cf125a815c7c06dead2a08e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8563a5cd67b0a7c38ea7568a03e908fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8563a5cd67b0a7c38ea7568a03e908fc"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a8563a5cd67b0a7c38ea7568a03e908fc">end</a> ()</td></tr>
<tr class="memdesc:a8563a5cd67b0a7c38ea7568a03e908fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the past-the-end iterator. <br /></td></tr>
<tr class="separator:a8563a5cd67b0a7c38ea7568a03e908fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e7b76e779e3e5d73cd9012b47573a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8e7b76e779e3e5d73cd9012b47573a3"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#aa8e7b76e779e3e5d73cd9012b47573a3">end</a> () const</td></tr>
<tr class="memdesc:aa8e7b76e779e3e5d73cd9012b47573a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant past-the-end iterator. <br /></td></tr>
<tr class="separator:aa8e7b76e779e3e5d73cd9012b47573a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad5dbfaeabc2ae27b594e77f8e98c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1NSGAPopulation.html#a7ad5dbfaeabc2ae27b594e77f8e98c3d">front</a> (bool parallel=true) const </td></tr>
<tr class="memdesc:a7ad5dbfaeabc2ae27b594e77f8e98c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a nondominated subset of this population.  <a href="#a7ad5dbfaeabc2ae27b594e77f8e98c3d">More...</a><br /></td></tr>
<tr class="separator:a7ad5dbfaeabc2ae27b594e77f8e98c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7401fa92f1e4f610b1591f7c1d457931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgen_1_1BasePopulation.html#af73564a15c292253babac84911c0a1b9">Base::Val</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1NSGAPopulation.html#a7401fa92f1e4f610b1591f7c1d457931">front_v</a> (bool parallel=true) const </td></tr>
<tr class="memdesc:a7401fa92f1e4f610b1591f7c1d457931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a nondominated subset of this population.  <a href="#a7401fa92f1e4f610b1591f7c1d457931">More...</a><br /></td></tr>
<tr class="separator:a7401fa92f1e4f610b1591f7c1d457931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09103dea92b43e4f17b0fc41f52e7f56"><td class="memTemplParams" colspan="2">template&lt;double(*)(...) fun = std::exp, class Rng  = decltype(rng)&gt; </td></tr>
<tr class="memitem:a09103dea92b43e4f17b0fc41f52e7f56"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1NSGAPopulation.html#a09103dea92b43e4f17b0fc41f52e7f56">NSGASelect</a> (double bias, Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>)</td></tr>
<tr class="memdesc:a09103dea92b43e4f17b0fc41f52e7f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a candidate randomly chosen by the NSGA algorithm.  <a href="#a09103dea92b43e4f17b0fc41f52e7f56">More...</a><br /></td></tr>
<tr class="separator:a09103dea92b43e4f17b0fc41f52e7f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdd7701d51a8618e53a9d53c3ad77ba"><td class="memTemplParams" colspan="2">template&lt;double(*)(...) fun = std::exp, class Rng  = decltype(rng)&gt; </td></tr>
<tr class="memitem:a2bdd7701d51a8618e53a9d53c3ad77ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1NSGAPopulation.html#a2bdd7701d51a8618e53a9d53c3ad77ba">NSGASelect_v</a> (double bias, Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>)</td></tr>
<tr class="memdesc:a2bdd7701d51a8618e53a9d53c3ad77ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a candidate randomly chosen by the NSGA algorithm.  <a href="#a2bdd7701d51a8618e53a9d53c3ad77ba">More...</a><br /></td></tr>
<tr class="separator:a2bdd7701d51a8618e53a9d53c3ad77ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8f8214c60760a7bfe95f6501b13a8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c8f8214c60760a7bfe95f6501b13a8d"></a>
const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a2c8f8214c60760a7bfe95f6501b13a8d">operator[]</a> (size_t pos) const</td></tr>
<tr class="memdesc:a2c8f8214c60760a7bfe95f6501b13a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to a specified element by reference (no bounds checking). <br /></td></tr>
<tr class="separator:a2c8f8214c60760a7bfe95f6501b13a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fbea5985e45d2a6c26e22736ae9476"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1NSGAPopulation.html#a95fbea5985e45d2a6c26e22736ae9476">precompute</a> (bool parallel=true)</td></tr>
<tr class="memdesc:a95fbea5985e45d2a6c26e22736ae9476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the metainformation about the NSGA rank of each candidate.  <a href="#a95fbea5985e45d2a6c26e22736ae9476">More...</a><br /></td></tr>
<tr class="separator:a95fbea5985e45d2a6c26e22736ae9476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add39c116cebce0e7513fc068e3c40544"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#add39c116cebce0e7513fc068e3c40544">prune</a> (bool(*test)(const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;), size_t minSize=0, Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>)</td></tr>
<tr class="memdesc:add39c116cebce0e7513fc068e3c40544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the population by selective removal of candidates.  <a href="#add39c116cebce0e7513fc068e3c40544">More...</a><br /></td></tr>
<tr class="separator:add39c116cebce0e7513fc068e3c40544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1413777e4a371a3568bea8fec553ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#ada1413777e4a371a3568bea8fec553ae">prune</a> (bool(*test)(const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;, const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;), size_t minSize=0, bool randomize=true, Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>)</td></tr>
<tr class="memdesc:ada1413777e4a371a3568bea8fec553ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the population by selective removal of candidates.  <a href="#ada1413777e4a371a3568bea8fec553ae">More...</a><br /></td></tr>
<tr class="separator:ada1413777e4a371a3568bea8fec553ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b863e652f0d5efd8e5cfb778a3e639b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a6b863e652f0d5efd8e5cfb778a3e639b">randomSelect</a> (Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>) const</td></tr>
<tr class="memdesc:a6b863e652f0d5efd8e5cfb778a3e639b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a candidate chosen using uniform random selection.  <a href="#a6b863e652f0d5efd8e5cfb778a3e639b">More...</a><br /></td></tr>
<tr class="separator:a6b863e652f0d5efd8e5cfb778a3e639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3cbb347caa1ce1d23395e67c984d30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a6b3cbb347caa1ce1d23395e67c984d30">randomSelect</a> (size_t k, Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>) const</td></tr>
<tr class="memdesc:a6b3cbb347caa1ce1d23395e67c984d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly selects <b>k</b> different candidates. If <b>k ≥ <a class="el" href="classgen_1_1BasePopulation.html#a6e1dafb2914f6718e67c24eaa58ac8f1" title="Returns the current count of candidates. ">size()</a></b>, the entire population is returned.  <a href="#a6b3cbb347caa1ce1d23395e67c984d30">More...</a><br /></td></tr>
<tr class="separator:a6b3cbb347caa1ce1d23395e67c984d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c476a26f71df13366cf476b0352d048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a0c476a26f71df13366cf476b0352d048">randomSelect_v</a> (Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>) const</td></tr>
<tr class="memdesc:a0c476a26f71df13366cf476b0352d048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a candidate chosen using uniform random selection.  <a href="#a0c476a26f71df13366cf476b0352d048">More...</a><br /></td></tr>
<tr class="separator:a0c476a26f71df13366cf476b0352d048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ade22892941a7fb0feffe84e73f228"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgen_1_1BasePopulation.html#af73564a15c292253babac84911c0a1b9">Val</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a63ade22892941a7fb0feffe84e73f228">randomSelect_v</a> (size_t k, Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>) const</td></tr>
<tr class="memdesc:a63ade22892941a7fb0feffe84e73f228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly selects <b>k</b> different candidates. If <b>k ≥ <a class="el" href="classgen_1_1BasePopulation.html#a6e1dafb2914f6718e67c24eaa58ac8f1" title="Returns the current count of candidates. ">size()</a></b>, the entire population is returned.  <a href="#a63ade22892941a7fb0feffe84e73f228">More...</a><br /></td></tr>
<tr class="separator:a63ade22892941a7fb0feffe84e73f228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72138c2c24aed9026a6ca3976e8d5f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#ad72138c2c24aed9026a6ca3976e8d5f0">randomTrim</a> (size_t newSize, Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>)</td></tr>
<tr class="memdesc:ad72138c2c24aed9026a6ca3976e8d5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the population to a maximum size given by the argument, using random selection if the latter is smaller.  <a href="#ad72138c2c24aed9026a6ca3976e8d5f0">More...</a><br /></td></tr>
<tr class="separator:ad72138c2c24aed9026a6ca3976e8d5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08151d51e9134cd006d5b16f7232fbd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a08151d51e9134cd006d5b16f7232fbd7">reserve</a> (size_t count)</td></tr>
<tr class="memdesc:a08151d51e9134cd006d5b16f7232fbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space for <b>count</b> candidates.  <a href="#a08151d51e9134cd006d5b16f7232fbd7">More...</a><br /></td></tr>
<tr class="separator:a08151d51e9134cd006d5b16f7232fbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1dafb2914f6718e67c24eaa58ac8f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e1dafb2914f6718e67c24eaa58ac8f1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a6e1dafb2914f6718e67c24eaa58ac8f1">size</a> ()</td></tr>
<tr class="memdesc:a6e1dafb2914f6718e67c24eaa58ac8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current count of candidates. <br /></td></tr>
<tr class="separator:a6e1dafb2914f6718e67c24eaa58ac8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class CBase, bool is_ref = false&gt;<br />
class gen::NSGAPopulation&lt; CBase, is_ref &gt;</h3>

<p>A variant of <a class="el" href="classgen_1_1Population.html" title="The main Population template, representing a collection of Candidates. This is the entry point of mos...">Population</a> enabling nondominance sorting and related selection methods. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CBase</td><td>the base class of the member candidates of this population. The type returned by <b>CBase::fitness()</b> must implement a strict partial order (<b>a</b> <em>dominates</em> <b>b</b>) given by a <b>bool operator&lt;&lt;()</b>, otherwise a compile-time error is generated. </td></tr>
    <tr><td class="paramname">is_ref</td><td>if set to <b>true</b>, this is a reference population. See <a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref </a> for more details. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa296f081375ad8b83ec5531ab33a2e1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::<a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a> =  <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a> &lt;CBase, true&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A corresponding "reference population", a helper type for functions returning a selection from an existing population. </p>
<p>This is the return type of functions that return a subset of an existing population by reference as it holds its members by reference rather than by value. Internally it is another Population specialization with a matching <b>CBase</b> type, so the same functions including adding or erasing can be called on it despite its dependent nature and assignments between Population and <b>Population::Ref</b> objects are allowed and behave as expected, see <a class="el" href="classgen_1_1BasePopulation.html#a6472f9b40dd1c1e6da79e76c9c22dc77" title="Copies all candidates from a container of Candidates. ">add(const Container&amp;)</a> and <a class="el" href="classgen_1_1BasePopulation.html#ad4513a92632c32a8e85509e6b9f38b3b" title="Moves all candidates from a container of Candidates. ">add(Container&amp;&amp;)</a>.</p>
<p>It is guaranteed that <b>Population::Ref::Ref</b> is identical to <b>Population::Ref</b>, which makes it convenient to chain selection functions, e.g. </p><div class="fragment"><div class="line">pop.randomSelect(5).front().randomSelect()</div></div><!-- fragment --><p> for a simple multi-objective tournament selection.</p>
<p>It is the user's responsibility not to use the references beyond their scope. They are invalidated by operations which modify the original population, namely all operations adding, removing, and reordering its elements. This includes functions like <a class="el" href="classgen_1_1OrdPopulation.html#a2c535509c7c304bb4d7572fc1f923349">rankSelect() </a>, which needs to sort the contents for its operation, and <a class="el" href="classgen_1_1BasePopulation.html#a08151d51e9134cd006d5b16f7232fbd7" title="Reserves space for count candidates. ">reserve()</a>, which may move the contents to a new memory location. </p>

</div>
</div>
<a class="anchor" id="af73564a15c292253babac84911c0a1b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::<a class="el" href="classgen_1_1BasePopulation.html#af73564a15c292253babac84911c0a1b9">Val</a> =  <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a> &lt;CBase, false&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A corresponding "value population", a helper type for functions returning a selection from an existing population by value. </p>
<p>In the case of a <a class="el" href="classgen_1_1Population.html">Population&lt;CBase&gt; </a> this will be identical to the calling class. However, when requested from a <a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">reference population </a>, this will remove the reference character thereof, so that elements stored in this type may outlive their original source.</p>
<p>It is guaranteed that <b>Population::Val::Val</b> = <b>Population::Ref::Val</b> = <b>Population::Val</b>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a174f881464476a392b8c21b9c0160da9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Source&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws <b>count</b> candidates from a source function <b>src</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of candidates to generate </td></tr>
    <tr><td class="paramname">src</td><td>source function; can be any callable object (e.g., a <b>std::function</b>, a function pointer, or a lambda function) returning either of <a class="el" href="classgen_1_1Candidate.html">Candidate&lt;CBase&gt; </a> or <b>CBase</b> and either by value or by reference (a copy will be taken). In many cases the function call can be inlined by the optimizer if known at compile time. </td></tr>
    <tr><td class="paramname">parallel</td><td>controls parallelization using OpenMP (on by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6472f9b40dd1c1e6da79e76c9c22dc77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all candidates from a container of <b>Candidate</b>s. </p>
<p>If this population is a reference population, references to all members of the argument are taken, copies are made otherwise. </p>

</div>
</div>
<a class="anchor" id="ad4513a92632c32a8e85509e6b9f38b3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves all candidates from a container of <b>Candidate</b>s. </p>
<p>Moves between populations are only supported if source and destination are both non-reference or both reference and are of the same <b>CBase</b> type. </p>

</div>
</div>
<a class="anchor" id="ab66c9833836830880d55f803a21f19d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<p>Note that using iterators to access the individual candidates in a Population circumvents the memory locking mechanisms. In any case references to members of a population are invalidated, so are any currently stored iterators. </p>

</div>
</div>
<a class="anchor" id="a9617849f9f39f1058ae5fdbc0a31fb3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the beginning. </p>
<p>Note that using iterators to access the individual candidates in a Population circumvents the memory locking mechanisms. In any case references to members of a population are invalidated, so are any currently stored iterators. </p>

</div>
</div>
<a class="anchor" id="a7ad5dbfaeabc2ae27b594e77f8e98c3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase , bool is_ref = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a> <a class="el" href="classgen_1_1NSGAPopulation.html">gen::NSGAPopulation</a>&lt; CBase, is_ref &gt;::front </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a nondominated subset of this population. </p>
<p>The returned <a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a> remains valid until the original population is modified. Therefore there is a risk of invalidating it in a multi-threaded program if another thread concurrently modifies the population. If your code allows this, use <a class="el" href="classgen_1_1NSGAPopulation.html#a7401fa92f1e4f610b1591f7c1d457931" title="Returns a nondominated subset of this population. ">front_v()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parallel</td><td>controls parallelization using OpenMP (on by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7401fa92f1e4f610b1591f7c1d457931"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase , bool is_ref = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgen_1_1BasePopulation.html#af73564a15c292253babac84911c0a1b9">Base::Val</a> <a class="el" href="classgen_1_1NSGAPopulation.html">gen::NSGAPopulation</a>&lt; CBase, is_ref &gt;::front_v </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a nondominated subset of this population. </p>
<p>Works like <a class="el" href="classgen_1_1NSGAPopulation.html#a7ad5dbfaeabc2ae27b594e77f8e98c3d" title="Returns a nondominated subset of this population. ">front()</a> but returns an independent population. </p>

</div>
</div>
<a class="anchor" id="a09103dea92b43e4f17b0fc41f52e7f56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase , bool is_ref = false&gt; </div>
<div class="memtemplate">
template&lt;double(*)(...) fun = std::exp, class Rng  = decltype(rng)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt;CBase&gt;&amp; <a class="el" href="classgen_1_1NSGAPopulation.html">gen::NSGAPopulation</a>&lt; CBase, is_ref &gt;::NSGASelect </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code><a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a candidate randomly chosen by the NSGA algorithm. </p>
<p>In determining the probability of each candidate, the length of the longest chain of candidates successively dominating it is identified and processed by a given function as described below, whose returned value is interpreted as an inverse probability.</p>
<p>The returned reference remains valid until the population is modified. Therefore there is a risk of invalidating it in a multi-threaded program if another thread concurrently modifies the population. If your code allows this, use <a class="el" href="classgen_1_1NSGAPopulation.html#a2bdd7701d51a8618e53a9d53c3ad77ba" title="Retrieves a candidate randomly chosen by the NSGA algorithm. ">NSGASelect_v()</a> instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">fun</td><td>A <b>constexpr</b> pointer to a function of signature either <b>double(*)(double)</b> or <b>double(*)(double, double)</b>. In the former case, the argument is <b>x * bias</b>, in the latter case the arguments are <b>x</b> and <b>bias</b>, where <b>x</b> denotes the dominance rank of the candidate. It must be positive and strictly increasing in <b>x</b> for <b>bias &gt; 0</b>. This function will be built in at compile time, eliminating a function pointer lookup. The default is <b>std::exp</b>, another usual choice is <b>std::pow</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bias</td><td>&gt; 0 determines how much low-dominated solutions are preferred. Zero would mean no account on dominance rank in the selection process whatsoever. The bigger the value the more low-dominated candidates are likely to be selected. </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator, or <a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3" title="The default random number generator for this framework. ">gen::rng</a> by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a constant reference to a randomly chosen candidate. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bdd7701d51a8618e53a9d53c3ad77ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase , bool is_ref = false&gt; </div>
<div class="memtemplate">
template&lt;double(*)(...) fun = std::exp, class Rng  = decltype(rng)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt;CBase&gt; <a class="el" href="classgen_1_1NSGAPopulation.html">gen::NSGAPopulation</a>&lt; CBase, is_ref &gt;::NSGASelect_v </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code><a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a candidate randomly chosen by the NSGA algorithm. </p>
<p>Works like <a class="el" href="classgen_1_1NSGAPopulation.html#a09103dea92b43e4f17b0fc41f52e7f56" title="Retrieves a candidate randomly chosen by the NSGA algorithm. ">NSGASelect()</a> but returns by value.</p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the randomly chosen candidate. </dd></dl>

</div>
</div>
<a class="anchor" id="a95fbea5985e45d2a6c26e22736ae9476"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase , bool is_ref = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1NSGAPopulation.html">gen::NSGAPopulation</a>&lt; CBase, is_ref &gt;::precompute </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the metainformation about the NSGA rank of each candidate. </p>
<p>This happens by default whenever <a class="el" href="classgen_1_1NSGAPopulation.html#a09103dea92b43e4f17b0fc41f52e7f56" title="Retrieves a candidate randomly chosen by the NSGA algorithm. ">NSGASelect()</a> is called after the population has been modified. However, since the sorting is a rather expensive operation, in a multithreaded setting this would mean all other threads have to wait for the calling thread to finish the sorting before proceeding. This method can be called before the work is split between threads, and as such, can benefit from parallelization itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parallel</td><td>controls parallelization using OpenMP (on by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add39c116cebce0e7513fc068e3c40544"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">bool(*)(const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;)&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code>rng</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the population by selective removal of candidates. </p>
<p>Candidates are tested against a given predicate. If a candidate <b>c</b> satisfies <b>pred(c)</b> it is removed from the population. A minimum number of candidates can be set; if so, the procedure stops when enough candidates have been removed to satisfy this bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>a boolean function accepting a constant <a class="el" href="classgen_1_1Candidate.html">Candidate&lt;CBase&gt;</a> reference. If the return value is <b>true</b> the candidate is removed from the population. </td></tr>
    <tr><td class="paramname">minSize</td><td>a minimum number of candidates to be kept if possible. If zero (the default value), all candidates satisfying the predicate are removed. </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator, or <a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3" title="The default random number generator for this framework. ">gen::rng</a> by default. Unused if <b>randomize</b> is <b>false</b>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada1413777e4a371a3568bea8fec553ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">bool(*)(const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;, const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;)&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>randomize</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code>rng</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the population by selective removal of candidates. </p>
<p>Candidates are tested for similarity according to a provided criterion function. If a pair of candidates (<b>a</b>, <b>b</b>) satisfies the test, only <b>a</b> is kept. A minimum number of candidates can be set; if so, the procedure stops when enough candidates have been removed to satisfy this bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>a boolean function accepting two constant <a class="el" href="classgen_1_1Candidate.html">Candidate&lt;CBase&gt;</a> references. Should be symmetric in its arguments. If the return value is <b>true</b> the latter candidate is removed from the population. </td></tr>
    <tr><td class="paramname">minSize</td><td>a minimum number of candidates to be kept if possible. If zero (the default value), all duplicates are removed. </td></tr>
    <tr><td class="paramname">randomize</td><td>whether to randomly shuffle the sample prior to pruning (this is the default). If <b>false</b> then earlier appearing candidates are preferred in survival. </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator, or <a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3" title="The default random number generator for this framework. ">gen::rng</a> by default. Unused if <b>randomize</b> is <b>false</b>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b863e652f0d5efd8e5cfb778a3e639b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt;CBase&gt;&amp; <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::randomSelect </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code>rng</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a candidate chosen using uniform random selection. </p>
<p>The returned reference remains valid until the population is modified. Therefore there is a risk of invalidating it in a multi-threaded program if another thread concurrently modifies the population. If your code allows this, use <a class="el" href="classgen_1_1BasePopulation.html#a0c476a26f71df13366cf476b0352d048">randomSelect_v(Rng&amp;) </a> instead. </p>

</div>
</div>
<a class="anchor" id="a6b3cbb347caa1ce1d23395e67c984d30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a> <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::randomSelect </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code>rng</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Randomly selects <b>k</b> different candidates. If <b>k ≥ <a class="el" href="classgen_1_1BasePopulation.html#a6e1dafb2914f6718e67c24eaa58ac8f1" title="Returns the current count of candidates. ">size()</a></b>, the entire population is returned. </p>
<p>The returned <a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a> remains valid until the original population is modified. Therefore there is a risk of invalidating it in a multi-threaded program if another thread concurrently modifies the population. If your code allows this, use <a class="el" href="classgen_1_1BasePopulation.html#a63ade22892941a7fb0feffe84e73f228">randomSelect_v(size_t, Rng&amp;) </a> instead. </p>

</div>
</div>
<a class="anchor" id="a0c476a26f71df13366cf476b0352d048"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt;CBase&gt; <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::randomSelect_v </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code>rng</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a candidate chosen using uniform random selection. </p>
<p>Works like <a class="el" href="classgen_1_1BasePopulation.html#a6b863e652f0d5efd8e5cfb778a3e639b">randomSelect(Rng&amp;) </a> but returns by value. </p>

</div>
</div>
<a class="anchor" id="a63ade22892941a7fb0feffe84e73f228"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgen_1_1BasePopulation.html#af73564a15c292253babac84911c0a1b9">Val</a> <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::randomSelect_v </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code>rng</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Randomly selects <b>k</b> different candidates. If <b>k ≥ <a class="el" href="classgen_1_1BasePopulation.html#a6e1dafb2914f6718e67c24eaa58ac8f1" title="Returns the current count of candidates. ">size()</a></b>, the entire population is returned. </p>
<p>Works like <a class="el" href="classgen_1_1BasePopulation.html#a6b3cbb347caa1ce1d23395e67c984d30">randomSelect(size_t, Rng&amp;) </a> but returns an independent population. </p>

</div>
</div>
<a class="anchor" id="ad72138c2c24aed9026a6ca3976e8d5f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::randomTrim </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code>rng</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the population to a maximum size given by the argument, using random selection if the latter is smaller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the maximum desired size of the population. If this bound is satisfied, the population is unchanged. </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator, or <a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3" title="The default random number generator for this framework. ">gen::rng</a> by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08151d51e9134cd006d5b16f7232fbd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, size_t , <a class="el" href="classgen_1_1NSGAPopulation.html">NSGAPopulation</a>  &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves space for <b>count</b> candidates. </p>
<p>If <b>count</b> is larger than the actual size of the population, all references may be invalidated. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
