<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Genetic framework: gen::DomPopulation&lt; CBase, is_ref, Tag, Population &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Genetic framework
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegen.html">gen</a></li><li class="navelem"><a class="el" href="classgen_1_1DomPopulation.html">DomPopulation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classgen_1_1DomPopulation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">gen::DomPopulation&lt; CBase, is_ref, Tag, Population &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classgen_1_1DomPopulation.html" title="The DomPopulation template, adding functionality dependent on dominance relation between candidates t...">DomPopulation</a> template, adding functionality dependent on dominance relation between candidates to a <a class="el" href="classgen_1_1BasePopulation.html" title="The BasePopulation template, covering functionality common to all the derived Population classes...">BasePopulation</a>. Base class of <a class="el" href="classgen_1_1NSGAPopulation.html" title="A variant of Population enabling nondominance sorting and related selection methods. ">NSGAPopulation</a>.  
 <a href="classgen_1_1DomPopulation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DomPopulation_8hpp_source.html">DomPopulation.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for gen::DomPopulation&lt; CBase, is_ref, Tag, Population &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classgen_1_1DomPopulation.png" usemap="#gen::DomPopulation_3C_20CBase_2C_20is_5Fref_2C_20Tag_2C_20Population_20_3E_map" alt=""/>
  <map id="gen::DomPopulation_3C_20CBase_2C_20is_5Fref_2C_20Tag_2C_20Population_20_3E_map" name="gen::DomPopulation&lt; CBase, is_ref, Tag, Population &gt;_map">
<area href="classgen_1_1BasePopulation.html" title="The BasePopulation template, covering functionality common to all the derived Population classes..." alt="gen::BasePopulation&lt; CBase, is_ref, Tag, Population &gt;" shape="rect" coords="0,56,326,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa296f081375ad8b83ec5531ab33a2e1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a> = <a class="el" href="classgen_1_1Population.html">Population</a>&lt; CBase, true &gt;</td></tr>
<tr class="memdesc:aa296f081375ad8b83ec5531ab33a2e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A corresponding "reference population", a helper type for functions returning a selection from an existing population.  <a href="#aa296f081375ad8b83ec5531ab33a2e1a">More...</a><br /></td></tr>
<tr class="separator:aa296f081375ad8b83ec5531ab33a2e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73564a15c292253babac84911c0a1b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#af73564a15c292253babac84911c0a1b9">Val</a> = <a class="el" href="classgen_1_1Population.html">Population</a>&lt; CBase, false &gt;</td></tr>
<tr class="memdesc:af73564a15c292253babac84911c0a1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A corresponding "value population", a helper type for functions returning a selection from an existing population by value.  <a href="#af73564a15c292253babac84911c0a1b9">More...</a><br /></td></tr>
<tr class="separator:af73564a15c292253babac84911c0a1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada8837a28f5ee5b83a93302ca0ffe68e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada8837a28f5ee5b83a93302ca0ffe68e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1DomPopulation.html#ada8837a28f5ee5b83a93302ca0ffe68e">DomPopulation</a> ()=default</td></tr>
<tr class="memdesc:ada8837a28f5ee5b83a93302ca0ffe68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty population. <br /></td></tr>
<tr class="separator:ada8837a28f5ee5b83a93302ca0ffe68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4b90d27c1ca5032cc0d3440ecfeac3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf4b90d27c1ca5032cc0d3440ecfeac3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#abf4b90d27c1ca5032cc0d3440ecfeac3">add</a> (const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;c)</td></tr>
<tr class="memdesc:abf4b90d27c1ca5032cc0d3440ecfeac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new candidate. <br /></td></tr>
<tr class="separator:abf4b90d27c1ca5032cc0d3440ecfeac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce2ec723e9809796baf35a3a581594b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ce2ec723e9809796baf35a3a581594b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a0ce2ec723e9809796baf35a3a581594b">add</a> (<a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;&amp;c)</td></tr>
<tr class="memdesc:a0ce2ec723e9809796baf35a3a581594b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes back a new candidate using the move semantics. <br /></td></tr>
<tr class="separator:a0ce2ec723e9809796baf35a3a581594b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174f881464476a392b8c21b9c0160da9"><td class="memTemplParams" colspan="2">template&lt;class Source &gt; </td></tr>
<tr class="memitem:a174f881464476a392b8c21b9c0160da9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a174f881464476a392b8c21b9c0160da9">add</a> (size_t count, Source src, bool parallel=true)</td></tr>
<tr class="memdesc:a174f881464476a392b8c21b9c0160da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws <b>count</b> candidates from a source function <b>src</b>.  <a href="#a174f881464476a392b8c21b9c0160da9">More...</a><br /></td></tr>
<tr class="separator:a174f881464476a392b8c21b9c0160da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d91a055117d8ba2b82e4ff3884e8945"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d91a055117d8ba2b82e4ff3884e8945"></a>
template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a4d91a055117d8ba2b82e4ff3884e8945"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a4d91a055117d8ba2b82e4ff3884e8945">add</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a4d91a055117d8ba2b82e4ff3884e8945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies an iterator range from a container of <b><a class="el" href="classgen_1_1Candidate.html" title="The Candidate template, wrapping a base candidate class to allow fitness caching. ...">Candidate</a></b>s. <br /></td></tr>
<tr class="separator:a4d91a055117d8ba2b82e4ff3884e8945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6472f9b40dd1c1e6da79e76c9c22dc77"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a6472f9b40dd1c1e6da79e76c9c22dc77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a6472f9b40dd1c1e6da79e76c9c22dc77">add</a> (const Container &amp;vec)</td></tr>
<tr class="memdesc:a6472f9b40dd1c1e6da79e76c9c22dc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all candidates from a container of <b><a class="el" href="classgen_1_1Candidate.html" title="The Candidate template, wrapping a base candidate class to allow fitness caching. ...">Candidate</a></b>s.  <a href="#a6472f9b40dd1c1e6da79e76c9c22dc77">More...</a><br /></td></tr>
<tr class="separator:a6472f9b40dd1c1e6da79e76c9c22dc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4513a92632c32a8e85509e6b9f38b3b"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:ad4513a92632c32a8e85509e6b9f38b3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#ad4513a92632c32a8e85509e6b9f38b3b">add</a> (Container &amp;&amp;vec)</td></tr>
<tr class="memdesc:ad4513a92632c32a8e85509e6b9f38b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all candidates from a container of <b><a class="el" href="classgen_1_1Candidate.html" title="The Candidate template, wrapping a base candidate class to allow fitness caching. ...">Candidate</a></b>s.  <a href="#ad4513a92632c32a8e85509e6b9f38b3b">More...</a><br /></td></tr>
<tr class="separator:ad4513a92632c32a8e85509e6b9f38b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5483ae56718c2675b7028b90a156da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa5483ae56718c2675b7028b90a156da"></a>
const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#aaa5483ae56718c2675b7028b90a156da">at</a> (size_t pos) const </td></tr>
<tr class="memdesc:aaa5483ae56718c2675b7028b90a156da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to a specified element by reference (with bounds checking). <br /></td></tr>
<tr class="separator:aaa5483ae56718c2675b7028b90a156da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ece2b4e2b9294d8cb91de2986dd58b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25ece2b4e2b9294d8cb91de2986dd58b"></a>
<a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a25ece2b4e2b9294d8cb91de2986dd58b">at_v</a> (size_t pos) const </td></tr>
<tr class="memdesc:a25ece2b4e2b9294d8cb91de2986dd58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a specified element by value (with bounds checking) <br /></td></tr>
<tr class="separator:a25ece2b4e2b9294d8cb91de2986dd58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66c9833836830880d55f803a21f19d0"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#ab66c9833836830880d55f803a21f19d0">begin</a> ()</td></tr>
<tr class="memdesc:ab66c9833836830880d55f803a21f19d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="#ab66c9833836830880d55f803a21f19d0">More...</a><br /></td></tr>
<tr class="separator:ab66c9833836830880d55f803a21f19d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9617849f9f39f1058ae5fdbc0a31fb3f"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a9617849f9f39f1058ae5fdbc0a31fb3f">begin</a> () const </td></tr>
<tr class="memdesc:a9617849f9f39f1058ae5fdbc0a31fb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator to the beginning.  <a href="#a9617849f9f39f1058ae5fdbc0a31fb3f">More...</a><br /></td></tr>
<tr class="separator:a9617849f9f39f1058ae5fdbc0a31fb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c77a3cf125a815c7c06dead2a08e75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31c77a3cf125a815c7c06dead2a08e75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a31c77a3cf125a815c7c06dead2a08e75">clear</a> ()</td></tr>
<tr class="memdesc:a31c77a3cf125a815c7c06dead2a08e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the population. <br /></td></tr>
<tr class="separator:a31c77a3cf125a815c7c06dead2a08e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8563a5cd67b0a7c38ea7568a03e908fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8563a5cd67b0a7c38ea7568a03e908fc"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a8563a5cd67b0a7c38ea7568a03e908fc">end</a> ()</td></tr>
<tr class="memdesc:a8563a5cd67b0a7c38ea7568a03e908fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the past-the-end iterator. <br /></td></tr>
<tr class="separator:a8563a5cd67b0a7c38ea7568a03e908fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e7b76e779e3e5d73cd9012b47573a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8e7b76e779e3e5d73cd9012b47573a3"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#aa8e7b76e779e3e5d73cd9012b47573a3">end</a> () const </td></tr>
<tr class="memdesc:aa8e7b76e779e3e5d73cd9012b47573a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant past-the-end iterator. <br /></td></tr>
<tr class="separator:aa8e7b76e779e3e5d73cd9012b47573a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744d986a4cd20d16940702cc4ab550a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1DomPopulation.html#a744d986a4cd20d16940702cc4ab550a2">front</a> (bool parallel=true) const </td></tr>
<tr class="memdesc:a744d986a4cd20d16940702cc4ab550a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a nondominated subset of this population.  <a href="#a744d986a4cd20d16940702cc4ab550a2">More...</a><br /></td></tr>
<tr class="separator:a744d986a4cd20d16940702cc4ab550a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0027eb9cef63d9428135e90aa402daf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgen_1_1BasePopulation.html#af73564a15c292253babac84911c0a1b9">Base::Val</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1DomPopulation.html#a0027eb9cef63d9428135e90aa402daf8">front_v</a> (bool parallel=true) const </td></tr>
<tr class="memdesc:a0027eb9cef63d9428135e90aa402daf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a nondominated subset of this population.  <a href="#a0027eb9cef63d9428135e90aa402daf8">More...</a><br /></td></tr>
<tr class="separator:a0027eb9cef63d9428135e90aa402daf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8f8214c60760a7bfe95f6501b13a8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c8f8214c60760a7bfe95f6501b13a8d"></a>
const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a2c8f8214c60760a7bfe95f6501b13a8d">operator[]</a> (size_t pos) const </td></tr>
<tr class="memdesc:a2c8f8214c60760a7bfe95f6501b13a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to a specified element by reference (no bounds checking). <br /></td></tr>
<tr class="separator:a2c8f8214c60760a7bfe95f6501b13a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add39c116cebce0e7513fc068e3c40544"><td class="memTemplParams" colspan="2">template&lt;class Rng  = decltype(rng)&gt; </td></tr>
<tr class="memitem:add39c116cebce0e7513fc068e3c40544"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#add39c116cebce0e7513fc068e3c40544">prune</a> (bool(*test)(const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;), size_t minSize=0, Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>)</td></tr>
<tr class="memdesc:add39c116cebce0e7513fc068e3c40544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the population by selective removal of candidates.  <a href="#add39c116cebce0e7513fc068e3c40544">More...</a><br /></td></tr>
<tr class="separator:add39c116cebce0e7513fc068e3c40544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1413777e4a371a3568bea8fec553ae"><td class="memTemplParams" colspan="2">template&lt;class Rng  = decltype(rng)&gt; </td></tr>
<tr class="memitem:ada1413777e4a371a3568bea8fec553ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#ada1413777e4a371a3568bea8fec553ae">prune</a> (bool(*test)(const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;, const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;), size_t minSize=0, bool randomize=true, Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>)</td></tr>
<tr class="memdesc:ada1413777e4a371a3568bea8fec553ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the population by selective removal of candidates.  <a href="#ada1413777e4a371a3568bea8fec553ae">More...</a><br /></td></tr>
<tr class="separator:ada1413777e4a371a3568bea8fec553ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b863e652f0d5efd8e5cfb778a3e639b"><td class="memTemplParams" colspan="2">template&lt;class Rng  = decltype(rng)&gt; </td></tr>
<tr class="memitem:a6b863e652f0d5efd8e5cfb778a3e639b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a6b863e652f0d5efd8e5cfb778a3e639b">randomSelect</a> (Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>) const </td></tr>
<tr class="memdesc:a6b863e652f0d5efd8e5cfb778a3e639b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a candidate chosen using uniform random selection.  <a href="#a6b863e652f0d5efd8e5cfb778a3e639b">More...</a><br /></td></tr>
<tr class="separator:a6b863e652f0d5efd8e5cfb778a3e639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3cbb347caa1ce1d23395e67c984d30"><td class="memTemplParams" colspan="2">template&lt;class Rng  = decltype(rng)&gt; </td></tr>
<tr class="memitem:a6b3cbb347caa1ce1d23395e67c984d30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a6b3cbb347caa1ce1d23395e67c984d30">randomSelect</a> (size_t k, Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>) const </td></tr>
<tr class="memdesc:a6b3cbb347caa1ce1d23395e67c984d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly selects <b>k</b> different candidates. If <b>k ≥ <a class="el" href="classgen_1_1BasePopulation.html#a6e1dafb2914f6718e67c24eaa58ac8f1" title="Returns the current count of candidates. ">size()</a></b>, the entire population is returned.  <a href="#a6b3cbb347caa1ce1d23395e67c984d30">More...</a><br /></td></tr>
<tr class="separator:a6b3cbb347caa1ce1d23395e67c984d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c476a26f71df13366cf476b0352d048"><td class="memTemplParams" colspan="2">template&lt;class Rng  = decltype(rng)&gt; </td></tr>
<tr class="memitem:a0c476a26f71df13366cf476b0352d048"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a0c476a26f71df13366cf476b0352d048">randomSelect_v</a> (Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>) const </td></tr>
<tr class="memdesc:a0c476a26f71df13366cf476b0352d048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a candidate chosen using uniform random selection.  <a href="#a0c476a26f71df13366cf476b0352d048">More...</a><br /></td></tr>
<tr class="separator:a0c476a26f71df13366cf476b0352d048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ade22892941a7fb0feffe84e73f228"><td class="memTemplParams" colspan="2">template&lt;class Rng  = decltype(rng)&gt; </td></tr>
<tr class="memitem:a63ade22892941a7fb0feffe84e73f228"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgen_1_1BasePopulation.html#af73564a15c292253babac84911c0a1b9">Val</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a63ade22892941a7fb0feffe84e73f228">randomSelect_v</a> (size_t k, Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>) const </td></tr>
<tr class="memdesc:a63ade22892941a7fb0feffe84e73f228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly selects <b>k</b> different candidates. If <b>k ≥ <a class="el" href="classgen_1_1BasePopulation.html#a6e1dafb2914f6718e67c24eaa58ac8f1" title="Returns the current count of candidates. ">size()</a></b>, the entire population is returned.  <a href="#a63ade22892941a7fb0feffe84e73f228">More...</a><br /></td></tr>
<tr class="separator:a63ade22892941a7fb0feffe84e73f228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72138c2c24aed9026a6ca3976e8d5f0"><td class="memTemplParams" colspan="2">template&lt;class Rng  = decltype(rng)&gt; </td></tr>
<tr class="memitem:ad72138c2c24aed9026a6ca3976e8d5f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#ad72138c2c24aed9026a6ca3976e8d5f0">randomTrim</a> (size_t newSize, Rng &amp;<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>=<a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a>)</td></tr>
<tr class="memdesc:ad72138c2c24aed9026a6ca3976e8d5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the population to a maximum size given by the argument, using random selection if the latter is smaller.  <a href="#ad72138c2c24aed9026a6ca3976e8d5f0">More...</a><br /></td></tr>
<tr class="separator:ad72138c2c24aed9026a6ca3976e8d5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08151d51e9134cd006d5b16f7232fbd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a08151d51e9134cd006d5b16f7232fbd7">reserve</a> (size_t count)</td></tr>
<tr class="memdesc:a08151d51e9134cd006d5b16f7232fbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space for <b>count</b> candidates.  <a href="#a08151d51e9134cd006d5b16f7232fbd7">More...</a><br /></td></tr>
<tr class="separator:a08151d51e9134cd006d5b16f7232fbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1dafb2914f6718e67c24eaa58ac8f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e1dafb2914f6718e67c24eaa58ac8f1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1BasePopulation.html#a6e1dafb2914f6718e67c24eaa58ac8f1">size</a> ()</td></tr>
<tr class="memdesc:a6e1dafb2914f6718e67c24eaa58ac8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current count of candidates. <br /></td></tr>
<tr class="separator:a6e1dafb2914f6718e67c24eaa58ac8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6c828237ae4e87dd37c63decc74bb567"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c828237ae4e87dd37c63decc74bb567"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1DomPopulation.html#a6c828237ae4e87dd37c63decc74bb567">operator&lt;&lt;</a> (const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;c, const <a class="el" href="classgen_1_1DomPopulation.html">DomPopulation</a> &amp;pop)</td></tr>
<tr class="memdesc:a6c828237ae4e87dd37c63decc74bb567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of candidates in this population dominated by a given candidate. <br /></td></tr>
<tr class="separator:a6c828237ae4e87dd37c63decc74bb567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c9bc055a2baee018f3bce709a7165"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a5c9bc055a2baee018f3bce709a7165"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgen_1_1DomPopulation.html#a7a5c9bc055a2baee018f3bce709a7165">operator&lt;&lt;</a> (const <a class="el" href="classgen_1_1DomPopulation.html">DomPopulation</a> &amp;pop, const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;c)</td></tr>
<tr class="memdesc:a7a5c9bc055a2baee018f3bce709a7165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of candidates in this population that dominate a given candidate. <br /></td></tr>
<tr class="separator:a7a5c9bc055a2baee018f3bce709a7165"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt;<br />
class gen::DomPopulation&lt; CBase, is_ref, Tag, Population &gt;</h3>

<p>The <a class="el" href="classgen_1_1DomPopulation.html" title="The DomPopulation template, adding functionality dependent on dominance relation between candidates t...">DomPopulation</a> template, adding functionality dependent on dominance relation between candidates to a <a class="el" href="classgen_1_1BasePopulation.html" title="The BasePopulation template, covering functionality common to all the derived Population classes...">BasePopulation</a>. Base class of <a class="el" href="classgen_1_1NSGAPopulation.html" title="A variant of Population enabling nondominance sorting and related selection methods. ">NSGAPopulation</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CBase</td><td>the base class of the member candidates of this population. See <a class="el" href="classgen_1_1Candidate.html" title="The Candidate template, wrapping a base candidate class to allow fitness caching. ...">Candidate</a> for details. </td></tr>
    <tr><td class="paramname">is_ref</td><td>if set to <b>true</b>, this is a reference population. See <a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a" title="A corresponding &quot;reference population&quot;, a helper type for functions returning a selection from an exi...">BasePopulation::Ref</a> for more details. </td></tr>
    <tr><td class="paramname">Tag</td><td>a class or literal type to accompany each candidate, used for internal purposes. This does not enter iterations over this population and is not duplicated when copies or references are taken. Must represent a default-constructible type. </td></tr>
    <tr><td class="paramname"><a class="el" href="classgen_1_1Population.html" title="The main Population template, representing a collection of Candidates. This is the entry point of mos...">Population</a></td><td>the outer <a class="el" href="classgen_1_1Population.html" title="The main Population template, representing a collection of Candidates. This is the entry point of mos...">Population</a> type this should behave like. Controls the return type of selection functions. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa296f081375ad8b83ec5531ab33a2e1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::<a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a> =  <a class="el" href="classgen_1_1Population.html">Population</a>&lt;CBase, true&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A corresponding "reference population", a helper type for functions returning a selection from an existing population. </p>
<p>This is the return type of functions that return a subset of an existing population by reference as it holds its members by reference rather than by value. Internally it is another <a class="el" href="classgen_1_1Population.html" title="The main Population template, representing a collection of Candidates. This is the entry point of mos...">Population</a> specialization with a matching <b>CBase</b> type, so the same functions including adding or erasing can be called on it despite its dependent nature and assignments between <a class="el" href="classgen_1_1Population.html" title="The main Population template, representing a collection of Candidates. This is the entry point of mos...">Population</a> and <b>Population::Ref</b> objects are allowed and behave as expected, see <a class="el" href="classgen_1_1BasePopulation.html#a6472f9b40dd1c1e6da79e76c9c22dc77" title="Copies all candidates from a container of Candidates. ">add(const Container&amp;)</a> and <a class="el" href="classgen_1_1BasePopulation.html#ad4513a92632c32a8e85509e6b9f38b3b" title="Moves all candidates from a container of Candidates. ">add(Container&amp;&amp;)</a>.</p>
<p>It is guaranteed that <b>Population::Ref::Ref</b> is identical to <b>Population::Ref</b>, which makes it convenient to chain selection functions, e.g. </p><div class="fragment"><div class="line">pop.randomSelect(5).front().randomSelect()</div></div><!-- fragment --><p> for a simple multi-objective tournament selection.</p>
<p>It is the user's responsibility not to use the references beyond their scope. They are invalidated by operations which modify the original population, namely all operations adding, removing, and reordering its elements. This includes functions like <a class="el" href="classgen_1_1OrdPopulation.html#a2c535509c7c304bb4d7572fc1f923349">rankSelect() </a>, which needs to sort the contents for its operation, and <a class="el" href="classgen_1_1BasePopulation.html#a08151d51e9134cd006d5b16f7232fbd7" title="Reserves space for count candidates. ">reserve()</a>, which may move the contents to a new memory location. </p>

</div>
</div>
<a class="anchor" id="af73564a15c292253babac84911c0a1b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::<a class="el" href="classgen_1_1BasePopulation.html#af73564a15c292253babac84911c0a1b9">Val</a> =  <a class="el" href="classgen_1_1Population.html">Population</a>&lt;CBase, false&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A corresponding "value population", a helper type for functions returning a selection from an existing population by value. </p>
<p>In the case of a <a class="el" href="classgen_1_1Population.html">Population&lt;CBase&gt; </a> this will be identical to the calling class. However, when requested from a <a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">reference population </a>, this will remove the reference character thereof, so that elements stored in this type may outlive their original source.</p>
<p>It is guaranteed that <b>Population::Val::Val</b> = <b>Population::Ref::Val</b> = <b>Population::Val</b>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a174f881464476a392b8c21b9c0160da9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<div class="memtemplate">
template&lt;class Source &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::add </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Source&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws <b>count</b> candidates from a source function <b>src</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the number of candidates to generate </td></tr>
    <tr><td class="paramname">src</td><td>source function; can be any callable object (e.g., a <b>std::function</b>, a function pointer, or a lambda function) returning either of <a class="el" href="classgen_1_1Candidate.html">Candidate&lt;CBase&gt; </a> or <b>CBase</b> and either by value or by reference (a copy will be taken). In many cases the function call can be inlined by the optimizer if known at compile time. </td></tr>
    <tr><td class="paramname">parallel</td><td>controls parallelization using OpenMP (on by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6472f9b40dd1c1e6da79e76c9c22dc77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all candidates from a container of <b><a class="el" href="classgen_1_1Candidate.html" title="The Candidate template, wrapping a base candidate class to allow fitness caching. ...">Candidate</a></b>s. </p>
<p>If this population is a reference population, references to all members of the argument are taken, copies are made otherwise. </p>

</div>
</div>
<a class="anchor" id="ad4513a92632c32a8e85509e6b9f38b3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::add </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves all candidates from a container of <b><a class="el" href="classgen_1_1Candidate.html" title="The Candidate template, wrapping a base candidate class to allow fitness caching. ...">Candidate</a></b>s. </p>
<p>Moves between populations are only supported if source and destination are both non-reference or both reference and are of the same <b>CBase</b> type. </p>

</div>
</div>
<a class="anchor" id="ab66c9833836830880d55f803a21f19d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<p>Note that using iterators to access the individual candidates in a <a class="el" href="classgen_1_1Population.html" title="The main Population template, representing a collection of Candidates. This is the entry point of mos...">Population</a> circumvents the memory locking mechanisms. In any case references to members of a population are invalidated, so are any currently stored iterators. </p>

</div>
</div>
<a class="anchor" id="a9617849f9f39f1058ae5fdbc0a31fb3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant iterator to the beginning. </p>
<p>Note that using iterators to access the individual candidates in a <a class="el" href="classgen_1_1Population.html" title="The main Population template, representing a collection of Candidates. This is the entry point of mos...">Population</a> circumvents the memory locking mechanisms. In any case references to members of a population are invalidated, so are any currently stored iterators. </p>

</div>
</div>
<a class="anchor" id="a744d986a4cd20d16940702cc4ab550a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a> <a class="el" href="classgen_1_1DomPopulation.html">gen::DomPopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::front </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a nondominated subset of this population. </p>
<p>The returned <a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a> remains valid until the original population is modified. Therefore there is a risk of invalidating it in a multi-threaded program if another thread concurrently modifies the population. If your code allows this, use <a class="el" href="classgen_1_1DomPopulation.html#a0027eb9cef63d9428135e90aa402daf8" title="Returns a nondominated subset of this population. ">front_v()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parallel</td><td>controls parallelization using OpenMP (on by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0027eb9cef63d9428135e90aa402daf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgen_1_1BasePopulation.html#af73564a15c292253babac84911c0a1b9">Base::Val</a> <a class="el" href="classgen_1_1DomPopulation.html">gen::DomPopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::front_v </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a nondominated subset of this population. </p>
<p>Works like <a class="el" href="classgen_1_1DomPopulation.html#a744d986a4cd20d16940702cc4ab550a2" title="Returns a nondominated subset of this population. ">front()</a> but returns an independent population. </p>

</div>
</div>
<a class="anchor" id="add39c116cebce0e7513fc068e3c40544"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<div class="memtemplate">
template&lt;class Rng  = decltype(rng)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">bool(*)(const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;)&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code><a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the population by selective removal of candidates. </p>
<p>Candidates are tested against a given predicate. If a candidate <b>c</b> satisfies <b>pred(c)</b> it is removed from the population. A minimum number of candidates can be set; if so, the procedure stops when enough candidates have been removed to satisfy this bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>a boolean function accepting a constant <a class="el" href="classgen_1_1Candidate.html">Candidate&lt;CBase&gt;</a> reference. If the return value is <b>true</b> the candidate is removed from the population. </td></tr>
    <tr><td class="paramname">minSize</td><td>a minimum number of candidates to be kept if possible. If zero (the default value), all candidates satisfying the predicate are removed. </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator, or <a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3" title="The default random number generator for this framework. ">gen::rng</a> by default. Unused if <b>randomize</b> is <b>false</b>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada1413777e4a371a3568bea8fec553ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<div class="memtemplate">
template&lt;class Rng  = decltype(rng)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">bool(*)(const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;, const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt; CBase &gt; &amp;)&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>randomize</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code><a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the population by selective removal of candidates. </p>
<p>Candidates are tested for similarity according to a provided criterion function. If a pair of candidates (<b>a</b>, <b>b</b>) satisfies the test, only <b>a</b> is kept. A minimum number of candidates can be set; if so, the procedure stops when enough candidates have been removed to satisfy this bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>a boolean function accepting two constant <a class="el" href="classgen_1_1Candidate.html">Candidate&lt;CBase&gt;</a> references. Should be symmetric in its arguments. If the return value is <b>true</b> the latter candidate is removed from the population. </td></tr>
    <tr><td class="paramname">minSize</td><td>a minimum number of candidates to be kept if possible. If zero (the default value), all duplicates are removed. </td></tr>
    <tr><td class="paramname">randomize</td><td>whether to randomly shuffle the sample prior to pruning (this is the default). If <b>false</b> then earlier appearing candidates are preferred in survival. </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator, or <a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3" title="The default random number generator for this framework. ">gen::rng</a> by default. Unused if <b>randomize</b> is <b>false</b>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b863e652f0d5efd8e5cfb778a3e639b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<div class="memtemplate">
template&lt;class Rng  = decltype(rng)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt;CBase&gt;&amp; <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::randomSelect </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code><a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a candidate chosen using uniform random selection. </p>
<p>The returned reference remains valid until the population is modified. Therefore there is a risk of invalidating it in a multi-threaded program if another thread concurrently modifies the population. If your code allows this, use <a class="el" href="classgen_1_1BasePopulation.html#a0c476a26f71df13366cf476b0352d048">randomSelect_v(Rng&amp;) </a> instead. </p>

</div>
</div>
<a class="anchor" id="a6b3cbb347caa1ce1d23395e67c984d30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<div class="memtemplate">
template&lt;class Rng  = decltype(rng)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a> <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::randomSelect </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code><a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Randomly selects <b>k</b> different candidates. If <b>k ≥ <a class="el" href="classgen_1_1BasePopulation.html#a6e1dafb2914f6718e67c24eaa58ac8f1" title="Returns the current count of candidates. ">size()</a></b>, the entire population is returned. </p>
<p>The returned <a class="el" href="classgen_1_1BasePopulation.html#aa296f081375ad8b83ec5531ab33a2e1a">Ref</a> remains valid until the original population is modified. Therefore there is a risk of invalidating it in a multi-threaded program if another thread concurrently modifies the population. If your code allows this, use <a class="el" href="classgen_1_1BasePopulation.html#a63ade22892941a7fb0feffe84e73f228">randomSelect_v(size_t, Rng&amp;) </a> instead. </p>

</div>
</div>
<a class="anchor" id="a0c476a26f71df13366cf476b0352d048"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<div class="memtemplate">
template&lt;class Rng  = decltype(rng)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgen_1_1Candidate.html">Candidate</a>&lt;CBase&gt; <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::randomSelect_v </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code><a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a candidate chosen using uniform random selection. </p>
<p>Works like <a class="el" href="classgen_1_1BasePopulation.html#a6b863e652f0d5efd8e5cfb778a3e639b">randomSelect(Rng&amp;) </a> but returns by value. </p>

</div>
</div>
<a class="anchor" id="a63ade22892941a7fb0feffe84e73f228"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<div class="memtemplate">
template&lt;class Rng  = decltype(rng)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgen_1_1BasePopulation.html#af73564a15c292253babac84911c0a1b9">Val</a> <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::randomSelect_v </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code><a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Randomly selects <b>k</b> different candidates. If <b>k ≥ <a class="el" href="classgen_1_1BasePopulation.html#a6e1dafb2914f6718e67c24eaa58ac8f1" title="Returns the current count of candidates. ">size()</a></b>, the entire population is returned. </p>
<p>Works like <a class="el" href="classgen_1_1BasePopulation.html#a6b3cbb347caa1ce1d23395e67c984d30">randomSelect(size_t, Rng&amp;) </a> but returns an independent population. </p>

</div>
</div>
<a class="anchor" id="ad72138c2c24aed9026a6ca3976e8d5f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<div class="memtemplate">
template&lt;class Rng  = decltype(rng)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::randomTrim </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em> = <code><a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3">rng</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the population to a maximum size given by the argument, using random selection if the latter is smaller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the maximum desired size of the population. If this bound is satisfied, the population is unchanged. </td></tr>
    <tr><td class="paramname">rng</td><td>the random number generator, or <a class="el" href="namespacegen.html#a04faf27861344c35e90aeffa5e5e97b3" title="The default random number generator for this framework. ">gen::rng</a> by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08151d51e9134cd006d5b16f7232fbd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CBase, bool is_ref, class Tag, template&lt; class, bool &gt; class Population&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classgen_1_1BasePopulation.html">gen::BasePopulation</a>&lt; CBase, is_ref, Tag, <a class="el" href="classgen_1_1Population.html">Population</a> &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves space for <b>count</b> candidates. </p>
<p>If <b>count</b> is larger than the actual size of the population, all references may be invalidated. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
